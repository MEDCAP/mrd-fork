# This file was generated by the "yardl" tool. DO NOT EDIT.

# pyright: reportUnusedImport=false
# pyright: reportUnknownArgumentType=false
# pyright: reportUnknownMemberType=false
# pyright: reportUnknownVariableType=false

import datetime
import enum
import types
import typing

import numpy as np
import numpy.typing as npt

from . import yardl_types as yardl
from . import _dtypes


class Header:
    """record corresponds to class definitions
    Header is a record with a single string field
    """

    subject: str

    def __init__(self, *,
        subject: str = "",
    ):
        self.subject = subject

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Header)
            and self.subject == other.subject
        )

    def __str__(self) -> str:
        return f"Header(subject={self.subject})"

    def __repr__(self) -> str:
        return f"Header(subject={repr(self.subject)})"


class Sample:
    """Sample is a record made up of a datetime and
    a vector of integers
    """

    data: list[yardl.Int32]
    """A vector of integers"""

    optional_data: typing.Optional[list[yardl.Int32]]

    def __init__(self, *,
        data: typing.Optional[list[yardl.Int32]] = None,
        optional_data: typing.Optional[list[yardl.Int32]] = None,
    ):
        self.data = data if data is not None else []
        self.optional_data = optional_data

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Sample)
            and self.data == other.data
            and self.optional_data == other.optional_data
        )

    def __str__(self) -> str:
        return f"Sample(data={self.data}, optionalData={self.optional_data})"

    def __repr__(self) -> str:
        return f"Sample(data={repr(self.data)}, optionalData={repr(self.optional_data)})"


class Point:
    x: yardl.UInt64
    y: yardl.Int32

    def __init__(self, *,
        x: yardl.UInt64 = 0,
        y: yardl.Int32 = 0,
    ):
        self.x = x
        self.y = y

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Point)
            and self.x == other.x
            and self.y == other.y
        )

    def __str__(self) -> str:
        return f"Point(x={self.x}, y={self.y})"

    def __repr__(self) -> str:
        return f"Point(x={repr(self.x)}, y={repr(self.y)})"


class Fruits(yardl.OutOfRangeEnum):
    APPLE = 0
    BANANA = 1
    PEAR = 2

def _mk_get_dtype():
    dtype_map: dict[typing.Union[type, types.GenericAlias], typing.Union[np.dtype[typing.Any], typing.Callable[[tuple[type, ...]], np.dtype[typing.Any]]]] = {}
    get_dtype = _dtypes.make_get_dtype_func(dtype_map)

    dtype_map.setdefault(Header, np.dtype([('subject', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(Sample, np.dtype([('data', np.dtype(np.object_)), ('optional_data', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True))], align=True))
    dtype_map.setdefault(Point, np.dtype([('x', np.dtype(np.uint64)), ('y', np.dtype(np.int32))], align=True))
    dtype_map.setdefault(Fruits, np.dtype(np.int32))

    return get_dtype

get_dtype = _mk_get_dtype()

